
==================== FINAL INTERFACE ====================
2016-02-01 00:09:08.455621 UTC

interface main@main:QualityMeasures 7103
  interface hash: be44fea98ac2274ccbf18e331ffbba15
  ABI hash: 23c4b97e163a977831a144ec15f09520
  export-list hash: f26cdfbf71bdb0a9d72e56fd3a1292a0
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f018113864ba7bd7bbf786476c05887f
  sig of: Nothing
  used TH splices: False
  where
exports:
  QualityMeasures.evalCond
  QualityMeasures.evalProp
  QualityMeasures.Code
  QualityMeasures.CodeList{QualityMeasures.Complete QualityMeasures.Partial}
  QualityMeasures.Cond
  QualityMeasures.Conditional{QualityMeasures.And QualityMeasures.Not QualityMeasures.Or QualityMeasures.Prop}
  QualityMeasures.Patient{QualityMeasures.Patient QualityMeasures.age QualityMeasures.diags QualityMeasures.procs}
  QualityMeasures.Prop{QualityMeasures.AgeGEQ QualityMeasures.CPT QualityMeasures.ICD10 QualityMeasures.Q}
  QualityMeasures.Test
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Either b111a97273971fe42fb746597ff3b293
import  -/  base-4.8.2.0:Data.Foldable 37c1dcdf6448d7800d277e5be0c3fc6f
import  -/  base-4.8.2.0:Data.Functor 5c701b0af1708f0192a25dfe14ce6274
import  -/  base-4.8.2.0:Data.Traversable b0a7b6ae330e162329aff67a837d49fc
import  -/  base-4.8.2.0:GHC.Base bf56e93e483b6a281ad97fedb63bfd04
import  -/  base-4.8.2.0:GHC.List ab53ad3f819f64915f1f91641b6e3255
import  -/  base-4.8.2.0:GHC.Read a0efbef3eddbb672968a527acbb18e69
import  -/  base-4.8.2.0:GHC.Show 81f797f6fb519cae2341362c0c4308de
import  -/  base-4.8.2.0:Prelude 0f9dd1bcfa413fa55bb6dca444292bf6
import  -/  base-4.8.2.0:Text.ParserCombinators.ReadPrec 2590e0e0a57a86ac7c62727f4d868dd2
import  -/  base-4.8.2.0:Text.Read.Lex f2eb8925a444d802011e19b105c28b26
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.Writer cf71944512d0bdc490a44e3d3b7f624e
import  -/  mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8:Control.Monad.Writer.Class eb235379059b66d91203e274e2178350
import  -/  transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Writer.Lazy 43d4df71ae946b82fdd25dfc76a149db
4a64225c2887f94a71853365bba31e4b
  $fEqCodeList :: GHC.Classes.Eq QualityMeasures.CodeList
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.CodeList
                  QualityMeasures.$fEqCodeList_$c==
                  QualityMeasures.$fEqCodeList_$c/= -}
4a64225c2887f94a71853365bba31e4b
  $fEqCodeList_$c/= ::
    QualityMeasures.CodeList
    -> QualityMeasures.CodeList -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a11 :: QualityMeasures.CodeList
                   b :: QualityMeasures.CodeList ->
                 case a11 of wild {
                   QualityMeasures.Partial a12
                   -> case b of wild1 {
                        QualityMeasures.Partial b1
                        -> case GHC.Classes.$fEq[]_$s$c==2 a12 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False }
                        QualityMeasures.Complete ipv -> GHC.Types.True }
                   QualityMeasures.Complete a12
                   -> case b of wild1 {
                        QualityMeasures.Partial ipv -> GHC.Types.True
                        QualityMeasures.Complete b1
                        -> case GHC.Classes.$fEq[]_$s$c==2 a12 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
4a64225c2887f94a71853365bba31e4b
  $fEqCodeList_$c== ::
    QualityMeasures.CodeList
    -> QualityMeasures.CodeList -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: QualityMeasures.CodeList
                   ds1 :: QualityMeasures.CodeList ->
                 case ds of wild {
                   QualityMeasures.Partial a11
                   -> case ds1 of wild1 {
                        QualityMeasures.Partial b1 -> GHC.Classes.$fEq[]_$s$c==2 a11 b1
                        QualityMeasures.Complete ipv -> GHC.Types.False }
                   QualityMeasures.Complete a11
                   -> case ds1 of wild1 {
                        QualityMeasures.Partial ipv -> GHC.Types.False
                        QualityMeasures.Complete b1
                        -> GHC.Classes.$fEq[]_$s$c==2 a11 b1 } }) -}
ea1ab8c567318548791e224b30c2326f
  $fEqConditional ::
    GHC.Classes.Eq p => GHC.Classes.Eq (QualityMeasures.Conditional p)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p $dEq :: GHC.Classes.Eq p.
                  @ (QualityMeasures.Conditional p)
                  (QualityMeasures.$fEqConditional_$c== @ p $dEq)
                  (QualityMeasures.$fEqConditional_$c/= @ p $dEq) -}
ea1ab8c567318548791e224b30c2326f
  $fEqConditional_$c/= ::
    GHC.Classes.Eq p =>
    QualityMeasures.Conditional p
    -> QualityMeasures.Conditional p -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   $dEq :: GHC.Classes.Eq p
                   a11 :: QualityMeasures.Conditional p
                   b :: QualityMeasures.Conditional p ->
                 case QualityMeasures.$fEqConditional_$c== @ p $dEq a11 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ea1ab8c567318548791e224b30c2326f
  $fEqConditional_$c== ::
    GHC.Classes.Eq p =>
    QualityMeasures.Conditional p
    -> QualityMeasures.Conditional p -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
0768ff469fb0391b09b03bff7854fd23
  $fEqPatient :: GHC.Classes.Eq QualityMeasures.Patient
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Patient
                  QualityMeasures.$fEqPatient_$c==
                  QualityMeasures.$fEqPatient_$c/= -}
0768ff469fb0391b09b03bff7854fd23
  $fEqPatient_$c/= ::
    QualityMeasures.Patient
    -> QualityMeasures.Patient -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a11 :: QualityMeasures.Patient b :: QualityMeasures.Patient ->
                 case QualityMeasures.$fEqPatient_$c== a11 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
0768ff469fb0391b09b03bff7854fd23
  $fEqPatient_$c== ::
    QualityMeasures.Patient
    -> QualityMeasures.Patient -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U)><S(SLL),1*U(1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: QualityMeasures.Patient w1 :: QualityMeasures.Patient ->
                 case w of ww { QualityMeasures.Patient ww1 ww2 ww3 ->
                 case w1 of ww4 { QualityMeasures.Patient ww5 ww6 ww7 ->
                 QualityMeasures.$w$c== ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fEqProp :: GHC.Classes.Eq QualityMeasures.Prop
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Prop
                  QualityMeasures.$fEqProp_$c==
                  QualityMeasures.$fEqProp_$c/= -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fEqProp_$c/= ::
    QualityMeasures.Prop -> QualityMeasures.Prop -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a11 :: QualityMeasures.Prop b :: QualityMeasures.Prop ->
                 case QualityMeasures.$fEqProp_$c== a11 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fEqProp_$c== ::
    QualityMeasures.Prop -> QualityMeasures.Prop -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: QualityMeasures.Prop
                   ds1 :: QualityMeasures.Prop ->
                 case ds of wild {
                   QualityMeasures.AgeGEQ a11
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        QualityMeasures.AgeGEQ b1 -> GHC.Classes.eqInt a11 b1 }
                   QualityMeasures.CPT a11 a12
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        QualityMeasures.CPT b1 b2
                        -> case GHC.Base.eqString a11 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.$fEq[]_$s$c==2 a12 b2 } }
                   QualityMeasures.ICD10 a11 a12
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        QualityMeasures.ICD10 b1 b2
                        -> case GHC.Base.eqString a11 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.$fEq[]_$s$c==2 a12 b2 } }
                   QualityMeasures.Q a11
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        QualityMeasures.Q b1 -> GHC.Base.eqString a11 b1 } }) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional ::
    Data.Foldable.Foldable QualityMeasures.Conditional
  DFunId[0]
  {- Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Conditional
                  QualityMeasures.$fFoldableConditional_$s$dmfold
                  QualityMeasures.$fFoldableConditional_$cfoldMap
                  QualityMeasures.$fFoldableConditional_$cfoldr
                  QualityMeasures.$fFoldableConditional_$cfoldr'
                  QualityMeasures.$fFoldableConditional_$cfoldl
                  QualityMeasures.$fFoldableConditional_$cfoldl'
                  QualityMeasures.$fFoldableConditional_$cfoldr1
                  QualityMeasures.$fFoldableConditional_$cfoldl1
                  QualityMeasures.$fFoldableConditional_$ctoList
                  QualityMeasures.$fFoldableConditional_$cnull
                  QualityMeasures.$fFoldableConditional_$clength
                  QualityMeasures.$fFoldableConditional_$celem
                  QualityMeasures.$fFoldableConditional_$cmaximum
                  QualityMeasures.$fFoldableConditional_$cminimum
                  QualityMeasures.$fFoldableConditional_$csum
                  QualityMeasures.$fFoldableConditional_$cproduct -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional1 ::
    GHC.Num.Num a3 =>
    QualityMeasures.Conditional a3 -> Data.Monoid.Product a3
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,A,U,A,A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a11 $dNum :: GHC.Num.Num a11 ->
                 QualityMeasures.$fFoldableConditional_$cfoldMap
                   @ a11
                   @ (Data.Monoid.Product a11)
                   (Data.Monoid.$fMonoidProduct @ a11 $dNum)
                   (\ tpl :: a11 -> tpl)
                     `cast`
                   (<a11>_R ->_R Sym (Data.Monoid.NTCo:Product[0] <a11>_R))) -}
5535a9920c4cac1b212669bced1be36a
  $fFoldableConditional10 ::
    GHC.Base.Monoid (Data.Monoid.Dual (Data.Monoid.Endo b))
  {- Unfolding: (\ @ b ->
                 Data.Monoid.$fMonoidDual
                   @ (Data.Monoid.Endo b)
                   (Data.Monoid.$fMonoidEndo @ b)) -}
50480746f3fd309c0a566092683e4de7
  $fFoldableConditional11 :: a3
  {- Strictness: b -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional2 ::
    GHC.Num.Num a3 =>
    QualityMeasures.Conditional a3 -> Data.Monoid.Sum a3
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,A,A,A,A,A,C(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a11 $dNum :: GHC.Num.Num a11 ->
                 QualityMeasures.$fFoldableConditional_$cfoldMap
                   @ a11
                   @ (Data.Monoid.Sum a11)
                   (Data.Monoid.$fMonoidSum @ a11 $dNum)
                   (\ tpl :: a11 -> tpl)
                     `cast`
                   (<a11>_R ->_R Sym (Data.Monoid.NTCo:Sum[0] <a11>_R))) -}
2575577e197f84974009766df2a4085f
  $fFoldableConditional3 :: a3
  {- Strictness: b -}
496ab558fa8d4b0a3f78d70f66b9aebe
  $fFoldableConditional4 :: a3
  {- Strictness: b -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional5 ::
    GHC.Classes.Eq a3 =>
    a3 -> QualityMeasures.Conditional a3 -> Data.Monoid.Any
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a11 $dEq :: GHC.Classes.Eq a11 eta :: a11 ->
                 QualityMeasures.$fFoldableConditional_$cfoldMap
                   @ a11
                   @ Data.Monoid.Any
                   Data.Monoid.$fMonoidAny
                   (GHC.Classes.== @ a11 $dEq eta)
                     `cast`
                   (<a11>_R ->_R Sym (Data.Monoid.NTCo:Any[0]))) -}
38e188db16f42d7b2e6e743f968d25a5
  $fFoldableConditional6 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
535635693f1b0900f1cf7cd46140551b
  $fFoldableConditional7 ::
    a3
    -> (GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Unfolding: (\ @ a11
                   x :: a11
                   k :: GHC.Types.Int -> GHC.Types.Int
                   z :: GHC.Types.Int ->
                 case z of wild { GHC.Types.I# x1 ->
                 k (GHC.Types.I# (GHC.Prim.+# x1 1)) }) -}
b935b0f2cc30df43cfd857ad0bde6c81
  $fFoldableConditional8 :: a3 -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a11 ds :: a11 ds1 :: GHC.Types.Bool -> GHC.Types.False) -}
2c0f1ab4d00f33df92a0ce0399f8f092
  $fFoldableConditional9 :: a3
  {- Strictness: b -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$celem ::
    GHC.Classes.Eq a =>
    a -> QualityMeasures.Conditional a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*C1(C(U)),A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fFoldableConditional5
                  `cast`
                (forall a11.
                 <GHC.Classes.Eq a11>_R
                 ->_R <a11>_R
                 ->_R <QualityMeasures.Conditional a11>_R
                 ->_R Data.Monoid.NTCo:Any[0]) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldMap ::
    GHC.Base.Monoid m => (a -> m) -> QualityMeasures.Conditional a -> m
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U,U,A)><L,C(U)><S,1*U> -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldl ::
    (b -> a -> b) -> b -> QualityMeasures.Conditional a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ b
                   @ a11
                   f :: b -> a11 -> b
                   z :: b
                   t1 :: QualityMeasures.Conditional a11 ->
                 (QualityMeasures.$fFoldableConditional_$cfoldMap
                    @ a11
                    @ (Data.Monoid.Dual (Data.Monoid.Endo b))
                    (QualityMeasures.$fFoldableConditional10 @ b)
                    (\ x :: a11 eta :: b -> f eta x)
                      `cast`
                    (<a11>_R
                     ->_R Sym (Data.Monoid.NTCo:Dual[0]
                                   (Data.Monoid.NTCo:Endo[0] <b>_R)))
                    t1)
                   `cast`
                 (Data.Monoid.NTCo:Dual[0] (Data.Monoid.NTCo:Endo[0] <b>_R))
                   z) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldl' ::
    (b -> a -> b) -> b -> QualityMeasures.Conditional a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ b
                   @ a11
                   f :: b -> a11 -> b
                   z0 :: b
                   xs :: QualityMeasures.Conditional a11 ->
                 (QualityMeasures.$fFoldableConditional_$cfoldMap
                    @ a11
                    @ (Data.Monoid.Endo (b -> b))
                    (Data.Monoid.$fMonoidEndo @ (b -> b))
                    (\ x :: a11 k :: b -> b z :: b ->
                     case f z x of vx { DEFAULT -> k vx })
                      `cast`
                    (<a11>_R ->_R Sym (Data.Monoid.NTCo:Endo[0] <b -> b>_R))
                    xs)
                   `cast`
                 (Data.Monoid.NTCo:Endo[0] <b -> b>_R)
                   (GHC.Base.id @ b)
                   z0) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldl1 ::
    (a -> a -> a) -> QualityMeasures.Conditional a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a11
                   f :: a11 -> a11 -> a11
                   xs :: QualityMeasures.Conditional a11 ->
                 case (QualityMeasures.$fFoldableConditional_$cfoldMap
                         @ a11
                         @ (Data.Monoid.Dual (Data.Monoid.Endo (GHC.Base.Maybe a11)))
                         (QualityMeasures.$fFoldableConditional10 @ (GHC.Base.Maybe a11))
                         (\ x :: a11 eta :: GHC.Base.Maybe a11 ->
                          GHC.Base.Just
                            @ a11
                            (case eta of wild {
                               GHC.Base.Nothing -> x GHC.Base.Just x1 -> f x1 x }))
                           `cast`
                         (<a11>_R
                          ->_R Sym (Data.Monoid.NTCo:Dual[0]
                                        (Data.Monoid.NTCo:Endo[0] <GHC.Base.Maybe a11>_R)))
                         xs)
                        `cast`
                      (Data.Monoid.NTCo:Dual[0]
                           (Data.Monoid.NTCo:Endo[0] <GHC.Base.Maybe a11>_R))
                        (GHC.Base.Nothing @ a11) of wild {
                   GHC.Base.Nothing -> QualityMeasures.$fFoldableConditional9 @ a11
                   GHC.Base.Just v -> v }) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldr ::
    (a -> b -> b) -> b -> QualityMeasures.Conditional a -> b
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><L,U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a11
                   @ b
                   f :: a11 -> b -> b
                   z :: b
                   t1 :: QualityMeasures.Conditional a11 ->
                 (QualityMeasures.$fFoldableConditional_$cfoldMap
                    @ a11
                    @ (Data.Monoid.Endo b)
                    (Data.Monoid.$fMonoidEndo @ b)
                    f `cast` (<a11>_R ->_R Sym (Data.Monoid.NTCo:Endo[0] <b>_R))
                    t1)
                   `cast`
                 (Data.Monoid.NTCo:Endo[0] <b>_R)
                   z) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldr' ::
    (a -> b -> b) -> b -> QualityMeasures.Conditional a -> b
  {- Arity: 3, Strictness: <L,C(C1(U))><L,U><S,1*U>,
     Unfolding: (\ @ a11
                   @ b
                   f :: a11 -> b -> b
                   z0 :: b
                   xs :: QualityMeasures.Conditional a11 ->
                 (QualityMeasures.$fFoldableConditional_$cfoldMap
                    @ a11
                    @ (Data.Monoid.Dual (Data.Monoid.Endo (b -> b)))
                    (QualityMeasures.$fFoldableConditional10 @ (b -> b))
                    (\ x :: a11 eta :: b -> b z :: b ->
                     case f x z of vx { DEFAULT -> eta vx })
                      `cast`
                    (<a11>_R
                     ->_R Sym (Data.Monoid.NTCo:Dual[0]
                                   (Data.Monoid.NTCo:Endo[0] <b -> b>_R)))
                    xs)
                   `cast`
                 (Data.Monoid.NTCo:Dual[0] (Data.Monoid.NTCo:Endo[0] <b -> b>_R))
                   (GHC.Base.id @ b)
                   z0) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cfoldr1 ::
    (a -> a -> a) -> QualityMeasures.Conditional a -> a
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a11
                   f :: a11 -> a11 -> a11
                   xs :: QualityMeasures.Conditional a11 ->
                 case (QualityMeasures.$fFoldableConditional_$cfoldMap
                         @ a11
                         @ (Data.Monoid.Endo (GHC.Base.Maybe a11))
                         (Data.Monoid.$fMonoidEndo @ (GHC.Base.Maybe a11))
                         (\ x :: a11 m :: GHC.Base.Maybe a11 ->
                          GHC.Base.Just
                            @ a11
                            (case m of wild {
                               GHC.Base.Nothing -> x GHC.Base.Just y -> f x y }))
                           `cast`
                         (<a11>_R
                          ->_R Sym (Data.Monoid.NTCo:Endo[0] <GHC.Base.Maybe a11>_R))
                         xs)
                        `cast`
                      (Data.Monoid.NTCo:Endo[0] <GHC.Base.Maybe a11>_R)
                        (GHC.Base.Nothing @ a11) of wild {
                   GHC.Base.Nothing -> QualityMeasures.$fFoldableConditional11 @ a11
                   GHC.Base.Just v -> v }) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$clength ::
    QualityMeasures.Conditional a -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a11 xs :: QualityMeasures.Conditional a11 ->
                 (QualityMeasures.$fFoldableConditional_$cfoldMap
                    @ a11
                    @ (Data.Monoid.Endo (GHC.Types.Int -> GHC.Types.Int))
                    (Data.Monoid.$fMonoidEndo @ (GHC.Types.Int -> GHC.Types.Int))
                    (QualityMeasures.$fFoldableConditional7 @ a11)
                      `cast`
                    (<a11>_R
                     ->_R Sym (Data.Monoid.NTCo:Endo[0]
                                   <GHC.Types.Int -> GHC.Types.Int>_R))
                    xs)
                   `cast`
                 (Data.Monoid.NTCo:Endo[0] <GHC.Types.Int -> GHC.Types.Int>_R)
                   (GHC.Base.id @ GHC.Types.Int)
                   QualityMeasures.$fFoldableConditional6) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cmaximum ::
    GHC.Classes.Ord a => QualityMeasures.Conditional a -> a
  {- Arity: 1, Strictness: <L,U(A,A,A,A,A,C(C1(U)),A,A)>,
     Unfolding: (\ @ a11 $dOrd :: GHC.Classes.Ord a11 ->
                 let {
                   a12 :: GHC.Base.Monoid (Data.Foldable.Max a11)
                   = Data.Foldable.$fMonoidMax @ a11 $dOrd
                 } in
                 \ x :: QualityMeasures.Conditional a11 ->
                 case (QualityMeasures.$fFoldableConditional_$cfoldMap
                         @ a11
                         @ (Data.Foldable.Max a11)
                         a12
                         (GHC.Base.Just @ a11)
                           `cast`
                         (<a11>_R ->_R Sym (Data.Foldable.NTCo:Max[0]) <a11>_N)
                         x)
                        `cast`
                      (Data.Foldable.NTCo:Max[0] <a11>_N) of wild {
                   GHC.Base.Nothing -> QualityMeasures.$fFoldableConditional4 @ a11
                   GHC.Base.Just v -> v }) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cminimum ::
    GHC.Classes.Ord a => QualityMeasures.Conditional a -> a
  {- Arity: 1, Strictness: <L,U(A,A,A,C(C1(U)),A,A,A,A)>,
     Unfolding: (\ @ a11 $dOrd :: GHC.Classes.Ord a11 ->
                 let {
                   a12 :: GHC.Base.Monoid (Data.Foldable.Min a11)
                   = Data.Foldable.$fMonoidMin @ a11 $dOrd
                 } in
                 \ x :: QualityMeasures.Conditional a11 ->
                 case (QualityMeasures.$fFoldableConditional_$cfoldMap
                         @ a11
                         @ (Data.Foldable.Min a11)
                         a12
                         (GHC.Base.Just @ a11)
                           `cast`
                         (<a11>_R ->_R Sym (Data.Foldable.NTCo:Min[0]) <a11>_N)
                         x)
                        `cast`
                      (Data.Foldable.NTCo:Min[0] <a11>_N) of wild {
                   GHC.Base.Nothing -> QualityMeasures.$fFoldableConditional3 @ a11
                   GHC.Base.Just v -> v }) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cnull ::
    QualityMeasures.Conditional a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a11 t1 :: QualityMeasures.Conditional a11 ->
                 (QualityMeasures.$fFoldableConditional_$cfoldMap
                    @ a11
                    @ (Data.Monoid.Endo GHC.Types.Bool)
                    (Data.Monoid.$fMonoidEndo @ GHC.Types.Bool)
                    (QualityMeasures.$fFoldableConditional8 @ a11)
                      `cast`
                    (<a11>_R ->_R Sym (Data.Monoid.NTCo:Endo[0] <GHC.Types.Bool>_R))
                    t1)
                   `cast`
                 (Data.Monoid.NTCo:Endo[0] <GHC.Types.Bool>_R)
                   GHC.Types.True) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$cproduct ::
    GHC.Num.Num a => QualityMeasures.Conditional a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(A,A,U,A,A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fFoldableConditional1
                  `cast`
                (forall a11.
                 <GHC.Num.Num a11>_R
                 ->_R <QualityMeasures.Conditional a11>_R
                 ->_R Data.Monoid.NTCo:Product[0] <a11>_R) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$csum ::
    GHC.Num.Num a => QualityMeasures.Conditional a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U,A,A,A,A,A,C(U))>,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fFoldableConditional2
                  `cast`
                (forall a11.
                 <GHC.Num.Num a11>_R
                 ->_R <QualityMeasures.Conditional a11>_R
                 ->_R Data.Monoid.NTCo:Sum[0] <a11>_R) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$ctoList ::
    QualityMeasures.Conditional a -> [a]
  {- Arity: 1, Strictness: <L,U>, Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ a11 t1 :: QualityMeasures.Conditional a11 ->
                 GHC.Base.build
                   @ a11
                   (\ @ b c :: a11 -> b -> b[OneShot] n :: b[OneShot] ->
                    QualityMeasures.$fFoldableConditional_$cfoldr @ a11 @ b c n t1)) -}
ea1ab8c567318548791e224b30c2326f
  $fFoldableConditional_$s$dmfold ::
    GHC.Base.Monoid m => QualityMeasures.Conditional m -> m
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U,U,A)>,
     Unfolding: InlineRule (-1, True, False)
                (\ @ m
                   $dMonoid :: GHC.Base.Monoid m
                   eta :: QualityMeasures.Conditional m ->
                 QualityMeasures.$fFoldableConditional_$cfoldMap
                   @ m
                   @ m
                   $dMonoid
                   (GHC.Base.id @ m)
                   eta) -}
ea1ab8c567318548791e224b30c2326f
  $fFunctorConditional ::
    GHC.Base.Functor QualityMeasures.Conditional
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Conditional
                  QualityMeasures.$fFunctorConditional_$cfmap
                  QualityMeasures.$fFunctorConditional_$c<$ -}
ea1ab8c567318548791e224b30c2326f
  $fFunctorConditional_$c<$ ::
    a -> QualityMeasures.Conditional b -> QualityMeasures.Conditional a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a11 @ b eta :: a11 eta1 :: QualityMeasures.Conditional b ->
                 QualityMeasures.$fFunctorConditional_$cfmap
                   @ b
                   @ a11
                   (\ ds :: b -> eta)
                   eta1) -}
ea1ab8c567318548791e224b30c2326f
  $fFunctorConditional_$cfmap ::
    (a -> b)
    -> QualityMeasures.Conditional a -> QualityMeasures.Conditional b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional ::
    GHC.Read.Read p => GHC.Read.Read (QualityMeasures.Conditional p)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p $dRead :: GHC.Read.Read p.
                  @ (QualityMeasures.Conditional p)
                  (QualityMeasures.$fReadConditional_$creadsPrec @ p $dRead)
                  (QualityMeasures.$fReadConditional_$creadList @ p $dRead)
                  (QualityMeasures.$fReadConditional_$creadPrec @ p $dRead)
                  (QualityMeasures.$fReadConditional_$creadListPrec @ p $dRead) -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional1 ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([QualityMeasures.Conditional p]
        -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   $dRead :: GHC.Read.Read p
                   eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [QualityMeasures.Conditional p]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ (QualityMeasures.Conditional p)
                   (QualityMeasures.$fReadConditional2 @ p $dRead)
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <QualityMeasures.Conditional p>_R))
                   @ b
                   eta1) -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional2 ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP
         (QualityMeasures.Conditional p)
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U> -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional_$creadList ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadP.ReadS [QualityMeasures.Conditional p]
  {- Arity: 1, Strictness: <L,U(A,A,U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ p $dRead :: GHC.Read.Read p ->
                 Text.ParserCombinators.ReadP.run
                   @ [QualityMeasures.Conditional p]
                   (GHC.Read.$wa
                      @ (QualityMeasures.Conditional p)
                      (QualityMeasures.$fReadConditional2 @ p $dRead)
                        `cast`
                      (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                <QualityMeasures.Conditional p>_R))
                      @ [QualityMeasures.Conditional p]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [QualityMeasures.Conditional p]))) -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional_$creadListPrec ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      [QualityMeasures.Conditional p]
  {- Arity: 3, Strictness: <L,U(A,A,U,A)><L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fReadConditional1
                  `cast`
                (forall p.
                 <GHC.Read.Read p>_R
                 ->_R Trans
                          (<Text.ParserCombinators.ReadPrec.Prec>_R
                           ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                         <[QualityMeasures.Conditional p]>_R))
                          (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                    <[QualityMeasures.Conditional p]>_R))) -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional_$creadPrec ::
    GHC.Read.Read p =>
    Text.ParserCombinators.ReadPrec.ReadPrec
      (QualityMeasures.Conditional p)
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fReadConditional2
                  `cast`
                (forall p.
                 <GHC.Read.Read p>_R
                 ->_R Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <QualityMeasures.Conditional p>_R)) -}
ea1ab8c567318548791e224b30c2326f
  $fReadConditional_$creadsPrec ::
    GHC.Read.Read p =>
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS
         (QualityMeasures.Conditional p)
  {- Arity: 2, Strictness: <L,U(A,A,U,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p $dRead :: GHC.Read.Read p eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadP.run
                   @ (QualityMeasures.Conditional p)
                   ((QualityMeasures.$fReadConditional2 @ p $dRead eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <QualityMeasures.Conditional p>_R)
                      @ (QualityMeasures.Conditional p)
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ (QualityMeasures.Conditional p)))) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp :: GHC.Read.Read QualityMeasures.Prop
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Prop
                  QualityMeasures.$fReadProp_$s$dmreadsPrec
                  QualityMeasures.$fReadProp_$sreadListDefault
                  QualityMeasures.$fReadProp_$creadPrec
                  QualityMeasures.$fReadProp_$creadListPrec -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([QualityMeasures.Prop] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ eta :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   eta1 :: [QualityMeasures.Prop]
                           -> Text.ParserCombinators.ReadP.P b ->
                 GHC.Read.$wa
                   @ QualityMeasures.Prop
                   QualityMeasures.$fReadProp2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                             <QualityMeasures.Prop>_R))
                   @ b
                   eta1) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP QualityMeasures.Prop
  {- Arity: 1,
     Unfolding: (GHC.Read.$fReadDouble10
                   @ QualityMeasures.Prop
                   QualityMeasures.$fReadProp3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                       <QualityMeasures.Prop>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                                  <QualityMeasures.Prop>_R)))) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (QualityMeasures.Prop -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <S,1*U(U)><L,C(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Text.ParserCombinators.ReadPrec.Prec
                   @ b
                   w1 :: QualityMeasures.Prop -> Text.ParserCombinators.ReadP.P b ->
                 case w of ww { GHC.Types.I# ww1 ->
                 QualityMeasures.$wa ww1 @ b w1 }) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [QualityMeasures.Prop]
  {- Arity: 2, Strictness: <L,A><L,C(U)>,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fReadProp1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                                    <[QualityMeasures.Prop]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                               <[QualityMeasures.Prop]>_R))) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec QualityMeasures.Prop
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.$fReadProp2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <QualityMeasures.Prop>_R)) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp_$s$dmreadsPrec ::
    GHC.Types.Int
    -> Text.ParserCombinators.ReadP.ReadS QualityMeasures.Prop
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (-1, True, False)
                (\ eta :: GHC.Types.Int ->
                 Text.ParserCombinators.ReadPrec.readPrec_to_S
                   @ QualityMeasures.Prop
                   QualityMeasures.$fReadProp_$creadPrec
                   eta) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fReadProp_$sreadListDefault ::
    Text.ParserCombinators.ReadP.ReadS [QualityMeasures.Prop]
  {- Arity: 1,
     Unfolding: InlineRule (0, True, False)
                (Text.ParserCombinators.ReadP.run
                   @ [QualityMeasures.Prop]
                   ((QualityMeasures.$fReadProp_$creadListPrec
                       `cast`
                     (Text.ParserCombinators.ReadPrec.NTCo:ReadPrec[0]
                          <[QualityMeasures.Prop]>_R)
                       GHC.Read.$fRead(,)7)
                      `cast`
                    (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                         <[QualityMeasures.Prop]>_R)
                      @ [QualityMeasures.Prop]
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$creturn
                         @ [QualityMeasures.Prop]))) -}
4a64225c2887f94a71853365bba31e4b
  $fShowCodeList :: GHC.Show.Show QualityMeasures.CodeList
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.CodeList
                  QualityMeasures.$fShowCodeList_$cshowsPrec
                  QualityMeasures.$fShowCodeList_$cshow
                  QualityMeasures.$fShowCodeList_$cshowList -}
4a64225c2887f94a71853365bba31e4b
  $fShowCodeList1 :: QualityMeasures.CodeList -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: QualityMeasures.CodeList
                   w1 :: GHC.Base.String ->
                 QualityMeasures.$w$cshowsPrec 0 w w1) -}
89045fcf3b5fa3b6079b820c1a668117
  $fShowCodeList2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Complete "#) -}
8ae0dc746bc89669e5e06a9da3e33ce4
  $fShowCodeList3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Partial "#) -}
4a64225c2887f94a71853365bba31e4b
  $fShowCodeList_$cshow ::
    QualityMeasures.CodeList -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: QualityMeasures.CodeList ->
                 QualityMeasures.$fShowCodeList_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
4a64225c2887f94a71853365bba31e4b
  $fShowCodeList_$cshowList ::
    [QualityMeasures.CodeList] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ QualityMeasures.CodeList
                   QualityMeasures.$fShowCodeList1) -}
4a64225c2887f94a71853365bba31e4b
  $fShowCodeList_$cshowsPrec ::
    GHC.Types.Int -> QualityMeasures.CodeList -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: QualityMeasures.CodeList
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 QualityMeasures.$w$cshowsPrec ww1 w1 w2 }) -}
ea1ab8c567318548791e224b30c2326f
  $fShowConditional ::
    GHC.Show.Show p => GHC.Show.Show (QualityMeasures.Conditional p)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ p $dShow :: GHC.Show.Show p.
                  @ (QualityMeasures.Conditional p)
                  (QualityMeasures.$fShowConditional_$cshowsPrec @ p $dShow)
                  (QualityMeasures.$fShowConditional_$cshow @ p $dShow)
                  (QualityMeasures.$fShowConditional_$cshowList @ p $dShow) -}
ea1ab8c567318548791e224b30c2326f
  $fShowConditional_$cshow ::
    GHC.Show.Show p => QualityMeasures.Conditional p -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ p
                   $dShow :: GHC.Show.Show p
                   x :: QualityMeasures.Conditional p ->
                 QualityMeasures.$fShowConditional_$cshowsPrec
                   @ p
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ea1ab8c567318548791e224b30c2326f
  $fShowConditional_$cshowList ::
    GHC.Show.Show p =>
    [QualityMeasures.Conditional p] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   $dShow :: GHC.Show.Show p
                   eta :: [QualityMeasures.Conditional p]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (QualityMeasures.Conditional p)
                   (QualityMeasures.$fShowConditional_$cshowsPrec
                      @ p
                      $dShow
                      QualityMeasures.$fFoldableConditional6)
                   eta
                   eta1) -}
ea1ab8c567318548791e224b30c2326f
  $fShowConditional_$cshowsPrec ::
    GHC.Show.Show p =>
    GHC.Types.Int -> QualityMeasures.Conditional p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ p
                   w :: GHC.Show.Show p
                   w1 :: GHC.Types.Int
                   w2 :: QualityMeasures.Conditional p ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 QualityMeasures.$w$cshowsPrec1 @ p w ww1 w2 }) -}
0768ff469fb0391b09b03bff7854fd23
  $fShowPatient :: GHC.Show.Show QualityMeasures.Patient
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Patient
                  QualityMeasures.$fShowPatient_$cshowsPrec
                  QualityMeasures.$fShowPatient_$cshow
                  QualityMeasures.$fShowPatient_$cshowList -}
0768ff469fb0391b09b03bff7854fd23
  $fShowPatient1 :: QualityMeasures.Patient -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: QualityMeasures.Patient ->
                 case w of ww { QualityMeasures.Patient ww1 ww2 ww3 ->
                 QualityMeasures.$w$cshowsPrec2 0 ww1 ww2 ww3 }) -}
9422617316485a9d767cbb3878d73ce9
  $fShowPatient2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
109bdc017557f8e391dd25f7fa9a3da5
  $fShowPatient3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "diags = "#) -}
6c53cf6f64edb87e09fde3d03c6b9297
  $fShowPatient4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "procs = "#) -}
33b8c1dc45b9fc83b81ddc060dd032a6
  $fShowPatient5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
a98beec5a13e19caf58c36f0187684c2
  $fShowPatient6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "age = "#) -}
c6b10e88bd40783eb89a01ed12243c8f
  $fShowPatient7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Patient {"#) -}
0768ff469fb0391b09b03bff7854fd23
  $fShowPatient_$cshow :: QualityMeasures.Patient -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: QualityMeasures.Patient ->
                 QualityMeasures.$fShowPatient_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0768ff469fb0391b09b03bff7854fd23
  $fShowPatient_$cshowList ::
    [QualityMeasures.Patient] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ QualityMeasures.Patient
                   QualityMeasures.$fShowPatient1) -}
0768ff469fb0391b09b03bff7854fd23
  $fShowPatient_$cshowsPrec ::
    GHC.Types.Int -> QualityMeasures.Patient -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: QualityMeasures.Patient ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { QualityMeasures.Patient ww3 ww4 ww5 ->
                 QualityMeasures.$w$cshowsPrec2 ww1 ww3 ww4 ww5 } }) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fShowProp :: GHC.Show.Show QualityMeasures.Prop
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Prop
                  QualityMeasures.$fShowProp_$cshowsPrec
                  QualityMeasures.$fShowProp_$cshow
                  QualityMeasures.$fShowProp_$cshowList -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fShowProp1 :: QualityMeasures.Prop -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: QualityMeasures.Prop w1 :: GHC.Base.String ->
                 QualityMeasures.$w$cshowsPrec3 0 w w1) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fShowProp_$cshow :: QualityMeasures.Prop -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: QualityMeasures.Prop ->
                 QualityMeasures.$fShowProp_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fShowProp_$cshowList :: [QualityMeasures.Prop] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ QualityMeasures.Prop
                   QualityMeasures.$fShowProp1) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $fShowProp_$cshowsPrec ::
    GHC.Types.Int -> QualityMeasures.Prop -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: QualityMeasures.Prop
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 QualityMeasures.$w$cshowsPrec3 ww1 w1 w2 }) -}
ea1ab8c567318548791e224b30c2326f
  $fTraversableConditional ::
    Data.Traversable.Traversable QualityMeasures.Conditional
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ QualityMeasures.Conditional
                  QualityMeasures.$fFunctorConditional
                  QualityMeasures.$fFoldableConditional
                  QualityMeasures.$fTraversableConditional_$ctraverse
                  QualityMeasures.$fTraversableConditional_$csequenceA
                  QualityMeasures.$fTraversableConditional_$cmapM
                  QualityMeasures.$fTraversableConditional_$csequence -}
ea1ab8c567318548791e224b30c2326f
  $fTraversableConditional_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b)
    -> QualityMeasures.Conditional a
    -> m (QualityMeasures.Conditional b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(U(U,U),C(U),C(C1(U)),A,A),A,A,A,A)><L,C(U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a11
                   @ (m :: * -> *)
                   @ b
                   $dMonad :: GHC.Base.Monad m
                   eta :: a11 -> m b
                   eta1 :: QualityMeasures.Conditional a11 ->
                 QualityMeasures.$fTraversableConditional_$ctraverse
                   @ a11
                   @ m
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)
                   eta
                   eta1) -}
ea1ab8c567318548791e224b30c2326f
  $fTraversableConditional_$csequence ::
    GHC.Base.Monad m =>
    QualityMeasures.Conditional (m a)
    -> m (QualityMeasures.Conditional a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLL)LLLL),1*U(1*U(U(U,U),C(U),C(C1(U)),A,A),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   @ a11
                   $dMonad :: GHC.Base.Monad m
                   eta :: QualityMeasures.Conditional (m a11) ->
                 QualityMeasures.$fTraversableConditional_$ctraverse
                   @ (m a11)
                   @ m
                   @ a11
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a11))
                   eta) -}
ea1ab8c567318548791e224b30c2326f
  $fTraversableConditional_$csequenceA ::
    GHC.Base.Applicative f =>
    QualityMeasures.Conditional (f a)
    -> f (QualityMeasures.Conditional a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U,U),C(U),C(C1(U)),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (f :: * -> *)
                   @ a11
                   $dApplicative :: GHC.Base.Applicative f
                   eta :: QualityMeasures.Conditional (f a11) ->
                 QualityMeasures.$fTraversableConditional_$ctraverse
                   @ (f a11)
                   @ f
                   @ a11
                   $dApplicative
                   (GHC.Base.id @ (f a11))
                   eta) -}
ea1ab8c567318548791e224b30c2326f
  $fTraversableConditional_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b)
    -> QualityMeasures.Conditional a
    -> f (QualityMeasures.Conditional b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLL),U(U(U,U),C(U),C(C1(U)),A,A)><L,C(U)><S,1*U> -}
7e7145cd37fb4949289c46599d183e2d
  $w$c== ::
    GHC.Base.Maybe GHC.Types.Int
    -> QualityMeasures.CodeList
    -> QualityMeasures.CodeList
    -> GHC.Base.Maybe GHC.Types.Int
    -> QualityMeasures.CodeList
    -> QualityMeasures.CodeList
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><S,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Base.Maybe GHC.Types.Int
                   ww1 :: QualityMeasures.CodeList
                   ww2 :: QualityMeasures.CodeList
                   ww3 :: GHC.Base.Maybe GHC.Types.Int
                   ww4 :: QualityMeasures.CodeList
                   ww5 :: QualityMeasures.CodeList ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ w :: GHC.Prim.Void#[OneShot] ->
                     case ww1 of wild {
                       QualityMeasures.Partial a11
                       -> case ww4 of wild1 {
                            QualityMeasures.Partial b1
                            -> case GHC.Classes.$fEq[]_$s$c==2 a11 b1 of wild2 {
                                 GHC.Types.False -> GHC.Types.False
                                 GHC.Types.True -> QualityMeasures.$fEqCodeList_$c== ww2 ww5 }
                            QualityMeasures.Complete ipv -> GHC.Types.False }
                       QualityMeasures.Complete a11
                       -> case ww4 of wild1 {
                            QualityMeasures.Partial ipv -> GHC.Types.False
                            QualityMeasures.Complete b1
                            -> case GHC.Classes.$fEq[]_$s$c==2 a11 b1 of wild2 {
                                 GHC.Types.False -> GHC.Types.False
                                 GHC.Types.True -> QualityMeasures.$fEqCodeList_$c== ww2 ww5 } } }
                 } in
                 case ww of wild {
                   GHC.Base.Nothing
                   -> case ww3 of wild1 {
                        GHC.Base.Nothing -> $j GHC.Prim.void#
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a11
                   -> case ww3 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1
                        -> case a11 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> $j GHC.Prim.void# } } } } }) -}
4a64225c2887f94a71853365bba31e4b
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> QualityMeasures.CodeList -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: QualityMeasures.CodeList
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   QualityMeasures.Partial b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             QualityMeasures.$fShowCodeList3
                             (GHC.Show.showList__
                                @ [GHC.Types.Char]
                                GHC.Show.shows_$cshowList
                                b1
                                w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                QualityMeasures.$fShowCodeList3
                                (GHC.Show.showList__
                                   @ [GHC.Types.Char]
                                   GHC.Show.shows_$cshowList
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) }
                   QualityMeasures.Complete b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             QualityMeasures.$fShowCodeList2
                             (GHC.Show.showList__
                                @ [GHC.Types.Char]
                                GHC.Show.shows_$cshowList
                                b1
                                w1)
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                QualityMeasures.$fShowCodeList2
                                (GHC.Show.showList__
                                   @ [GHC.Types.Char]
                                   GHC.Show.shows_$cshowList
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1))) } }) -}
ea1ab8c567318548791e224b30c2326f
  $w$cshowsPrec1 ::
    GHC.Show.Show p =>
    GHC.Prim.Int# -> QualityMeasures.Conditional p -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><L,U><S,1*U>,
     Inline: [0] -}
f4106257a1b2692f34407976eb5c7db8
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> GHC.Base.Maybe GHC.Types.Int
    -> QualityMeasures.CodeList
    -> QualityMeasures.CodeList
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Base.Maybe GHC.Types.Int
                   ww2 :: QualityMeasures.CodeList
                   ww3 :: QualityMeasures.CodeList ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ GHC.Types.Int
                       GHC.Show.$fShowInt
                       QualityMeasures.$fFoldableConditional6
                       ww1
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       QualityMeasures.$fShowPatient7
                       (GHC.Base.++
                          @ GHC.Types.Char
                          QualityMeasures.$fShowPatient6
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                QualityMeasures.$fShowPatient5
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   QualityMeasures.$fShowPatient4
                                   (QualityMeasures.$w$cshowsPrec
                                      0
                                      ww2
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         QualityMeasures.$fShowPatient5
                                         (GHC.Base.++
                                            @ GHC.Types.Char
                                            QualityMeasures.$fShowPatient3
                                            (QualityMeasures.$w$cshowsPrec
                                               0
                                               ww3
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  QualityMeasures.$fShowPatient2
                                                  x)))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> QualityMeasures.Prop -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
bf284bd2f6baeaea1473a4f211ad1f4c
  $w$s$ctraverse ::
    (a
     -> Control.Monad.Trans.Writer.Lazy.WriterT
          [QualityMeasures.Test] Data.Functor.Identity.Identity b)
    -> QualityMeasures.Conditional a
    -> (# QualityMeasures.Conditional b, [QualityMeasures.Test] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U(U,U))><S,1*U>,
     Inline: [0] -}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  $wa ::
    GHC.Prim.Int#
    -> forall b.
       (QualityMeasures.Prop -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,C(U)>, Inline: [0] -}
dd1663f205da17d4b496bc574c0c94b0
  $wa1 ::
    QualityMeasures.Cond
    -> QualityMeasures.Patient
    -> (# Data.Either.Either
            (QualityMeasures.Conditional QualityMeasures.Prop) GHC.Types.Bool,
          [QualityMeasures.Test] #)
  {- Arity: 2, Strictness: <L,1*U><L,U(U,U,U)>, Inline: [0],
     Unfolding: (\ w :: QualityMeasures.Cond
                   w1 :: QualityMeasures.Patient ->
                 let {
                   m1 :: Control.Monad.Trans.Writer.Lazy.WriterT
                           [QualityMeasures.Test]
                           Data.Functor.Identity.Identity
                           (QualityMeasures.Conditional
                              (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool))
                   = case QualityMeasures.$w$s$ctraverse
                            @ QualityMeasures.Prop
                            @ (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool)
                            (\ pr :: QualityMeasures.Prop ->
                             case QualityMeasures.evalProp pr w1 of wild {
                               GHC.Base.Nothing
                               -> (Data.Either.Left @ QualityMeasures.Prop @ GHC.Types.Bool pr,
                                   GHC.Types.[] @ (GHC.Types.Bool, QualityMeasures.Prop))
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                                 <(Data.Either.Either
                                                     QualityMeasures.Prop GHC.Types.Bool,
                                                   [QualityMeasures.Test])>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                 <[QualityMeasures.Test]>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <Data.Either.Either
                                                    QualityMeasures.Prop GHC.Types.Bool>_N)))
                               GHC.Base.Just b
                               -> (Data.Either.Right @ QualityMeasures.Prop @ GHC.Types.Bool b,
                                   GHC.Base.++
                                     @ (GHC.Types.Bool, QualityMeasures.Prop)
                                     (GHC.Types.:
                                        @ (GHC.Types.Bool, QualityMeasures.Prop)
                                        (b, pr)
                                        (GHC.Types.[] @ (GHC.Types.Bool, QualityMeasures.Prop)))
                                     (GHC.Types.[] @ (GHC.Types.Bool, QualityMeasures.Prop)))
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                                 <(Data.Either.Either
                                                     QualityMeasures.Prop GHC.Types.Bool,
                                                   [QualityMeasures.Test])>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                                 <[QualityMeasures.Test]>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <Data.Either.Either
                                                    QualityMeasures.Prop GHC.Types.Bool>_N))) })
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                    <(QualityMeasures.Conditional
                                        (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool),
                                      [QualityMeasures.Test])>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                    <[QualityMeasures.Test]>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <QualityMeasures.Conditional
                                       (Data.Either.Either
                                          QualityMeasures.Prop GHC.Types.Bool)>_N))) }
                 } in
                 let {
                   a11 :: Control.Monad.Trans.Writer.Lazy.WriterT
                            [QualityMeasures.Test]
                            Data.Functor.Identity.Identity
                            (Data.Either.Either
                               (QualityMeasures.Conditional QualityMeasures.Prop) GHC.Types.Bool)
                   = case m1
                            `cast`
                          (Trans
                               (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                    <[QualityMeasures.Test]>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <QualityMeasures.Conditional
                                       (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool)>_N)
                               (Data.Functor.Identity.NTCo:Identity[0]
                                    <(QualityMeasures.Conditional
                                        (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool),
                                      [QualityMeasures.Test])>_R)) of wild { (,) a12 w2 ->
                     case QualityMeasures.evalCond_prune
                            @ QualityMeasures.Prop
                            a12 of wild1 {
                       DEFAULT
                       -> (Data.Either.Left
                             @ (QualityMeasures.Conditional QualityMeasures.Prop)
                             @ GHC.Types.Bool
                             (QualityMeasures.$fFunctorConditional_$cfmap
                                @ (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool)
                                @ QualityMeasures.Prop
                                (QualityMeasures.evalCond_unpack
                                   @ QualityMeasures.Prop
                                   @ GHC.Types.Bool)
                                wild1),
                           GHC.Types.[] @ (GHC.Types.Bool, QualityMeasures.Prop))
                            `cast`
                          (Trans
                               (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                         <(Data.Either.Either
                                             (QualityMeasures.Conditional QualityMeasures.Prop)
                                             GHC.Types.Bool,
                                           [QualityMeasures.Test])>_R))
                               (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                         <[QualityMeasures.Test]>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <Data.Either.Either
                                            (QualityMeasures.Conditional QualityMeasures.Prop)
                                            GHC.Types.Bool>_N)))
                       QualityMeasures.Prop ds
                       -> case ds of wild2 {
                            Data.Either.Left ipv
                            -> (Data.Either.Left
                                  @ (QualityMeasures.Conditional QualityMeasures.Prop)
                                  @ GHC.Types.Bool
                                  (QualityMeasures.$fFunctorConditional_$cfmap
                                     @ (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool)
                                     @ QualityMeasures.Prop
                                     (QualityMeasures.evalCond_unpack
                                        @ QualityMeasures.Prop
                                        @ GHC.Types.Bool)
                                     wild1),
                                GHC.Types.[] @ (GHC.Types.Bool, QualityMeasures.Prop))
                                 `cast`
                               (Trans
                                    (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                              <(Data.Either.Either
                                                  (QualityMeasures.Conditional QualityMeasures.Prop)
                                                  GHC.Types.Bool,
                                                [QualityMeasures.Test])>_R))
                                    (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                              <[QualityMeasures.Test]>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <Data.Either.Either
                                                 (QualityMeasures.Conditional QualityMeasures.Prop)
                                                 GHC.Types.Bool>_N)))
                            Data.Either.Right b
                            -> (Data.Either.Right
                                  @ (QualityMeasures.Conditional QualityMeasures.Prop)
                                  @ GHC.Types.Bool
                                  b,
                                GHC.Types.[] @ (GHC.Types.Bool, QualityMeasures.Prop))
                                 `cast`
                               (Trans
                                    (Sym (Data.Functor.Identity.NTCo:Identity[0]
                                              <(Data.Either.Either
                                                  (QualityMeasures.Conditional QualityMeasures.Prop)
                                                  GHC.Types.Bool,
                                                [QualityMeasures.Test])>_R))
                                    (Sym (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                              <[QualityMeasures.Test]>_N
                                              <Data.Functor.Identity.Identity>_R
                                              <Data.Either.Either
                                                 (QualityMeasures.Conditional QualityMeasures.Prop)
                                                 GHC.Types.Bool>_N))) } } }
                 } in
                 (# case a11
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[QualityMeasures.Test]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <Data.Either.Either
                                      (QualityMeasures.Conditional QualityMeasures.Prop)
                                      GHC.Types.Bool>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(Data.Either.Either
                                       (QualityMeasures.Conditional QualityMeasures.Prop)
                                       GHC.Types.Bool,
                                     [QualityMeasures.Test])>_R)) of wild { (,) b1 w' ->
                    b1 },
                    case m1
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                   <[QualityMeasures.Test]>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <QualityMeasures.Conditional
                                      (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool)>_N)
                              (Data.Functor.Identity.NTCo:Identity[0]
                                   <(QualityMeasures.Conditional
                                       (Data.Either.Either QualityMeasures.Prop GHC.Types.Bool),
                                     [QualityMeasures.Test])>_R)) of wild { (,) a12 w2 ->
                    GHC.Base.++
                      @ (GHC.Types.Bool, QualityMeasures.Prop)
                      w2
                      (case a11
                              `cast`
                            (Trans
                                 (Control.Monad.Trans.Writer.Lazy.NTCo:WriterT[0]
                                      <[QualityMeasures.Test]>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <Data.Either.Either
                                         (QualityMeasures.Conditional QualityMeasures.Prop)
                                         GHC.Types.Bool>_N)
                                 (Data.Functor.Identity.NTCo:Identity[0]
                                      <(Data.Either.Either
                                          (QualityMeasures.Conditional QualityMeasures.Prop)
                                          GHC.Types.Bool,
                                        [QualityMeasures.Test])>_R)) of wild1 { (,) b1 w' ->
                       w' }) } #)) -}
ecf12961bab6d8fa99a690a912c23c0b
  type Code = GHC.Base.String
4a64225c2887f94a71853365bba31e4b
  data CodeList
    = Partial [QualityMeasures.Code] | Complete [QualityMeasures.Code]
10aa45289349827a1c1291d79b855b58
  type Cond = QualityMeasures.Conditional QualityMeasures.Prop
ea1ab8c567318548791e224b30c2326f
  data Conditional p
    = Prop p
    | Not (QualityMeasures.Conditional p)
    | And [QualityMeasures.Conditional p]
    | Or [QualityMeasures.Conditional p]
    Promotable
0768ff469fb0391b09b03bff7854fd23
  data Patient
    = Patient {age :: GHC.Base.Maybe GHC.Types.Int,
               procs :: QualityMeasures.CodeList,
               diags :: QualityMeasures.CodeList}
3bccca5e3d5ee1ed2fb66456f6ab6a97
  data Prop
    = AgeGEQ GHC.Types.Int
    | CPT GHC.Base.String [QualityMeasures.Code]
    | ICD10 GHC.Base.String [QualityMeasures.Code]
    | Q GHC.Base.String
0b99c308787a4a57db4482b0500e8c59
  type Test = (GHC.Types.Bool, QualityMeasures.Prop)
0407ff237d98c56b5f297f3e2fdf2332
  age :: QualityMeasures.Patient -> GHC.Base.Maybe GHC.Types.Int
  RecSel QualityMeasures.Patient
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: QualityMeasures.Patient ->
                 case ds of wild { QualityMeasures.Patient ds1 ds2 ds3 -> ds1 }) -}
b0a016c3147f3979ac338e9b2b419e10
  diags :: QualityMeasures.Patient -> QualityMeasures.CodeList
  RecSel QualityMeasures.Patient
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: QualityMeasures.Patient ->
                 case ds of wild { QualityMeasures.Patient ds1 ds2 ds3 -> ds3 }) -}
0b748db8780ed22fa43f398cc9a1d4a1
  evalCond ::
    QualityMeasures.Cond
    -> QualityMeasures.Patient
    -> (Data.Either.Either QualityMeasures.Cond GHC.Types.Bool,
        [QualityMeasures.Test])
  {- Arity: 2, Strictness: <L,1*U><L,U(U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                QualityMeasures.evalCond1
                  `cast`
                (<QualityMeasures.Cond>_R
                 ->_R <QualityMeasures.Patient>_R
                 ->_R Data.Functor.Identity.NTCo:Identity[0]
                          <(Data.Either.Either QualityMeasures.Cond GHC.Types.Bool,
                            [QualityMeasures.Test])>_R) -}
f15a1562aa81c91d57f7976fb0274f50
  evalCond1 ::
    QualityMeasures.Cond
    -> QualityMeasures.Patient
    -> Data.Functor.Identity.Identity
         (Data.Either.Either
            (QualityMeasures.Conditional QualityMeasures.Prop) GHC.Types.Bool,
          [QualityMeasures.Test])
  {- Arity: 2, Strictness: <L,1*U><L,U(U,U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: QualityMeasures.Cond w1 :: QualityMeasures.Patient ->
                 case QualityMeasures.$wa1 w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.NTCo:Identity[0]
                           <(Data.Either.Either
                               (QualityMeasures.Conditional QualityMeasures.Prop) GHC.Types.Bool,
                             [QualityMeasures.Test])>_R)) }) -}
21d931d5fadfd792309263b558bbe0da
  evalCond2 :: t
  {- Strictness: b -}
567cb4a6074ab89a37d36e88f2e3ae3d
  evalCond_prune ::
    QualityMeasures.Conditional (Data.Either.Either p GHC.Types.Bool)
    -> QualityMeasures.Conditional
         (Data.Either.Either p GHC.Types.Bool)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
99dcd254d3d5b2134fdd05298b972264
  evalCond_unpack :: Data.Either.Either t t1 -> t
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ t1 ds :: Data.Either.Either t t1 ->
                 case ds of wild {
                   Data.Either.Left prop -> prop
                   Data.Either.Right b -> QualityMeasures.evalCond2 @ t }) -}
685fd891bc3ff48873d6d00c2f0b0213
  evalProp ::
    QualityMeasures.Prop
    -> QualityMeasures.Patient -> GHC.Base.Maybe GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(1*U,1*U,1*U)>,
     Unfolding: (\ ds :: QualityMeasures.Prop
                   pat :: QualityMeasures.Patient ->
                 case ds of wild {
                   QualityMeasures.AgeGEQ n
                   -> case pat of wild1 { QualityMeasures.Patient ds1 ds2 ds3 ->
                      case ds1 of wild2 {
                        GHC.Base.Nothing -> GHC.Base.Nothing @ GHC.Types.Bool
                        GHC.Base.Just a11
                        -> GHC.Base.Just @ GHC.Types.Bool (GHC.Classes.geInt a11 n) } }
                   QualityMeasures.CPT ds1 xs
                   -> case pat of wild1 { QualityMeasures.Patient ds2 ds3 ds4 ->
                      case ds3 of wild2 {
                        QualityMeasures.Partial qs
                        -> letrec {
                             go :: [QualityMeasures.Code] -> Data.Monoid.Any
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ ds5 :: [QualityMeasures.Code] ->
                               case ds5 of wild3 {
                                 [] -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                                 : y ys
                                 -> case GHC.List.elem
                                           @ QualityMeasures.Code
                                           GHC.Classes.$fEq[]_$s$fEq[]1
                                           y
                                           qs of wild4 {
                                      GHC.Types.False -> go ys
                                      GHC.Types.True
                                      -> GHC.Types.True `cast` (Sym (Data.Monoid.NTCo:Any[0])) } }
                           } in
                           case (go xs) `cast` (Data.Monoid.NTCo:Any[0]) of wild3 {
                             GHC.Types.False -> GHC.Base.Nothing @ GHC.Types.Bool
                             GHC.Types.True -> QualityMeasures.evalProp1 }
                        QualityMeasures.Complete ps
                        -> GHC.Base.Just
                             @ GHC.Types.Bool
                             (letrec {
                                go :: [QualityMeasures.Code] -> Data.Monoid.Any
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ ds5 :: [QualityMeasures.Code] ->
                                  case ds5 of wild3 {
                                    [] -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                                    : y ys
                                    -> case GHC.List.elem
                                              @ QualityMeasures.Code
                                              GHC.Classes.$fEq[]_$s$fEq[]1
                                              y
                                              ps of wild4 {
                                         GHC.Types.False -> go ys
                                         GHC.Types.True
                                         -> GHC.Types.True
                                              `cast`
                                            (Sym (Data.Monoid.NTCo:Any[0])) } }
                              } in
                              (go xs) `cast` (Data.Monoid.NTCo:Any[0])) } }
                   QualityMeasures.ICD10 ds1 xs
                   -> case pat of wild1 { QualityMeasures.Patient ds2 ds3 ds4 ->
                      case ds4 of wild2 {
                        QualityMeasures.Partial qs
                        -> letrec {
                             go :: [QualityMeasures.Code] -> Data.Monoid.Any
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ ds5 :: [QualityMeasures.Code] ->
                               case ds5 of wild3 {
                                 [] -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                                 : y ys
                                 -> case GHC.List.elem
                                           @ QualityMeasures.Code
                                           GHC.Classes.$fEq[]_$s$fEq[]1
                                           y
                                           qs of wild4 {
                                      GHC.Types.False -> go ys
                                      GHC.Types.True
                                      -> GHC.Types.True `cast` (Sym (Data.Monoid.NTCo:Any[0])) } }
                           } in
                           case (go xs) `cast` (Data.Monoid.NTCo:Any[0]) of wild3 {
                             GHC.Types.False -> GHC.Base.Nothing @ GHC.Types.Bool
                             GHC.Types.True -> QualityMeasures.evalProp1 }
                        QualityMeasures.Complete ps
                        -> GHC.Base.Just
                             @ GHC.Types.Bool
                             (letrec {
                                go :: [QualityMeasures.Code] -> Data.Monoid.Any
                                  {- Arity: 1, Strictness: <S,1*U> -}
                                = \ ds5 :: [QualityMeasures.Code] ->
                                  case ds5 of wild3 {
                                    [] -> GHC.Types.False `cast` (Sym (Data.Monoid.NTCo:Any[0]))
                                    : y ys
                                    -> case GHC.List.elem
                                              @ QualityMeasures.Code
                                              GHC.Classes.$fEq[]_$s$fEq[]1
                                              y
                                              ps of wild4 {
                                         GHC.Types.False -> go ys
                                         GHC.Types.True
                                         -> GHC.Types.True
                                              `cast`
                                            (Sym (Data.Monoid.NTCo:Any[0])) } }
                              } in
                              (go xs) `cast` (Data.Monoid.NTCo:Any[0])) } }
                   QualityMeasures.Q ds1 -> GHC.Base.Nothing @ GHC.Types.Bool }) -}
50868278f5534eaa90829e79343888ef
  evalProp1 :: GHC.Base.Maybe GHC.Types.Bool
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just @ GHC.Types.Bool GHC.Types.True) -}
2018fb85db6e3e77b2f0e2740b8d9f62
  procs :: QualityMeasures.Patient -> QualityMeasures.CodeList
  RecSel QualityMeasures.Patient
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: QualityMeasures.Patient ->
                 case ds of wild { QualityMeasures.Patient ds1 ds2 ds3 -> ds2 }) -}
instance GHC.Classes.Eq [QualityMeasures.CodeList]
  = QualityMeasures.$fEqCodeList
instance GHC.Classes.Eq [QualityMeasures.Conditional]
  = QualityMeasures.$fEqConditional
instance GHC.Classes.Eq [QualityMeasures.Patient]
  = QualityMeasures.$fEqPatient
instance GHC.Classes.Eq [QualityMeasures.Prop]
  = QualityMeasures.$fEqProp
instance Data.Foldable.Foldable [QualityMeasures.Conditional]
  = QualityMeasures.$fFoldableConditional
instance GHC.Base.Functor [QualityMeasures.Conditional]
  = QualityMeasures.$fFunctorConditional
instance GHC.Read.Read [QualityMeasures.Conditional]
  = QualityMeasures.$fReadConditional
instance GHC.Read.Read [QualityMeasures.Prop]
  = QualityMeasures.$fReadProp
instance GHC.Show.Show [QualityMeasures.CodeList]
  = QualityMeasures.$fShowCodeList
instance GHC.Show.Show [QualityMeasures.Conditional]
  = QualityMeasures.$fShowConditional
instance GHC.Show.Show [QualityMeasures.Patient]
  = QualityMeasures.$fShowPatient
instance GHC.Show.Show [QualityMeasures.Prop]
  = QualityMeasures.$fShowProp
instance Data.Traversable.Traversable [QualityMeasures.Conditional]
  = QualityMeasures.$fTraversableConditional
"SPEC/QualityMeasures $dmfold @ Conditional" [ALWAYS] forall $dFoldable :: Data.Foldable.Foldable
                                                                             QualityMeasures.Conditional
  Data.Foldable.$dmfold @ QualityMeasures.Conditional $dFoldable
  = QualityMeasures.$fFoldableConditional_$s$dmfold
"SPEC/QualityMeasures $dmreadsPrec @ Prop" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                       QualityMeasures.Prop
  GHC.Read.$dmreadsPrec @ QualityMeasures.Prop $dRead
  = QualityMeasures.$fReadProp_$s$dmreadsPrec
"SPEC/QualityMeasures readListDefault @ Prop" [ALWAYS] forall $dRead :: GHC.Read.Read
                                                                          QualityMeasures.Prop
  GHC.Read.readListDefault @ QualityMeasures.Prop $dRead
  = QualityMeasures.$fReadProp_$sreadListDefault
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

